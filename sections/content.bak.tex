% !TeX encoding = UTF-8
% !TeX root = RosNavTuningCn.tex
% !TeX TS-program = xelatex.exe


\section[Velocity and Acceleration]{速度和加速度}
\parEnCn{
	This section concerns with synchro-drive robots. The dynamics (e.g. velocity and acceleration of the robot) of the robot is essential for local planners including dynamic window approach (DWA) and timed elastic band (TEB). 
	In ROS navigation stack, local planner
	takes in odometry messages ("odom" topic) and outputs velocity commands ("cmd\_vel" topic) that controls the robot's motion. 
	
	Max$/$min velocity and acceleration are two basic parameters for the mobile base. 
	Setting them correctly is very helpful for optimal local planner behavior. In ROS navigation, we need to know translational and rotational velocity and acceleration.	
}
{
	本节涉及同步驱动(synchro-drive)机器人。机器人的动力学特征(例如，机器人的速度和加速度)对于动态窗口法(Dynamic Window Approach, DWA)和定时弹性带(Timed Elastic Band, TEB)这两种局部规划器是必不可少的内容。
	在ROS的导航功能包中，局部规划器接收里程消息(“odom"话题)，输出控制机器人运动的速度指令(“cmd\_vel”话题)。
	
	最大/最小速度和加速度是移动基座的两个基本参数。
	正确设置这两个数值对优化局部规划器的移动行为帮助非常大。
	在ROS的导航中，我们需要知道平移和旋转的速度及加速度。	
}


\subsection[To obtain maximum velocity]{获取最大速度}
\parEnCn{
	Usually you can refer to your mobile base's manual. For example, SCITOS G5 has maximum velocity 1.4 m$/$s. In ROS, you can also subscribe to the \texttt{odom} topic to obtain the current odometry information. If you can control your robot manually (e.g. with a joystick), you can try to run it forward until its
	speed reaches constant, and then echo the odometry data.	
}
{
	一般可以参考你的移动基座的手册。例如，SCITOS G5的最大速度为1.4 m$/$s\footnote{此信息来自于\href{http://www.metralabs.com/en/research}{MetraLabs网站}。}。
	在ROS中，你还可以订阅\texttt{odom}话题以获取当前里程信息。如果你能手工控制机器人（例如使用操纵杆），则你可以尝试向前移动直到它的速度值达到常数，
	然后回显(echo)里程数据。
}

\parEnCn{
	\textit{Translational velocity} ($m/s$) is the velocity when robot is moving in a straight line. Its max value is the same as the maximum velocity we obtained above. \textit{Rotational velocity} ($rad/s$) is equivalent as angular velocity; its maximum value is the angular velocity of the robot when it is rotating in place. To obtain maximum rotational velocity, we can control the robot by a joystick and rotate the robot 360 degrees after the robot's speed reaches constant, and time this movement.	
}
{
	\textit{平移速度}($m/s$)是机器人沿直线移动时的速度。获取其最大值的方式与上面获取速度的最大值方式相同。\textit{旋转速度}（$rad/s$）等效于角速度;它的最大值是机器人在原地位置旋转时的角速度。为获取最大旋转速度，我们可以通过操纵杆控制机器人，在机器人的速度达到恒定值后将机器人旋转360度，并对此次运动进行计时。
}

%Another method is to measure the radius of the circumscribed circle of robot's footprint, then compute the maximum angular velocity by $\omega_{max}=v_{max}/r$.
\parEnCn{
	For safety, we prefer to set maximum translational and rotational velocities to be lower than their actual maximum values.	
}
{
	为安全起见，我们倾向于将最大平移速度和旋转速度设置为低于其实际最大值。	
}



\subsection[To obtain maximum acceleration]{获取最大加速度}
\parEnCn{
	There are many ways to measure maximum acceleration of your mobile base, if your manual does not tell you directly. 
	
	In ROS, again we can echo odometry data which include time stamps, and then see how long it took the robot to reach constant maximum translational velocity ($t_{i}$). Then we use the position and velocity information from odometry (nav\_msgs/Odometry message) to compute the acceleration in this process. Do several trails and take the average. Use $t_t, t_r$ to denote the time used to reach translationand and rotational maximum velocity from static, respectively. The maximum translational acceleration $a_{t,max}=\text{max }dv / dt\approx v_{max}/t_t$. Likewise, rotational acceleration can be computed by $a_{r,max}=\text{max }d\omega / dt\approx \omega_{max}/t_r$.	
}
{
	若您的手册没有直接告诉您该值大小，可通过很多方法测量您的移动基座的最大加速度。
	
	在ROS中，类似地，我们可以回显包含时间戳的里程数据，记下机器人达到最大平移速度时所花的时间（$t_{i}$）。
	之后我们利用里程计的位置和速度信息(nav\_msgs/Odometry消息)计算此过程中的加速度。
	多做几条不同的路径，计算其平均值。
	分别用$t_t$和$t_r$表示机器人从静止达到最大平移速度和最大旋转速度所需要的时间。
	则最大平移加速度为$a_{t,max}=\text{max }dv / dt\approx v_{max}/t_t$。
	同理，最大旋转加速度通过式$a_{r,max}=\text{max }d\omega / dt\approx \omega_{max}/t_r$计算。
}



% We can also use some physics method to measure accelerations. To measure translational acceleration, we can let the initially stationary robot
% move along a straight line with known length, and time its movement. Then plug in distance as $s$ and time as $t$ into this formula
% to obtain maximum translational acceleration:
% $$a_{trans}=\frac{2s}{t_{trans}^2}$$
% For maximum rotational acceleration, the method is almost the same. Let the initially stationary mobile base rotate in place for a certain number
% of full circles, and time its movement. Then, use this formula where $l$ is the total length of rotation and $t$ is the time:
% $$a_{rot}=\frac{2l}{t_{rot}^2}$$

\subsection[Setting minimum values]{设置最小值}
\parEnCn{
	Setting minimum velocity is not as formulaic as above. For minimum translational velocity, we want to set it to a large negative value
	because this enables the robot to back off when it needs to unstuck itself, but it should prefer moving forward in most cases. For minimum rotational velocity, we also want to set it to negative (if the parameter allows) so that the robot can rotate in either directions. Notice that DWA Local Planner takes the absolute value of robot's minimum rotational velocity.
}
{
	设置最小速度不必像上述公式那么正式。 
	对于最小平移速度，我们希望将其设置为较大的负值，
	因为这样可以让机器人在需要自救时进行回退，虽然在大多数实际情况下它应该前进。
	对于最小旋转速度，我们希望将其设置为负值（若参数允许的情况下），以便机器人可以在任一方向上旋转。 
	注意，DWA局部规划器采用的是机器人最小旋转速度的绝对值。
}

\subsection[Velocity in x, y direction]{x,y方向上的速度}
\parEnCn{
	\textbf{$x$ velocity} means the velocity in the direction parallel to robot's straight movement. It is the same as translational velocity. \textbf{$y$ velocity} is the velocity in the direction perpendicular to that straight movement. It is called "strafing velocity" in \texttt{teb\_local\_planner}. $y$ velocity should be set to zero for non-holonomic robot (such as
	differential wheeled robots).
}
{
	\textbf{$x$ velocity}表示平行于机器人直线运动方向的速度。它与平移速度相同。
	\textbf{$y$ velocity}是垂直于该直线运动方向的速度。
	在\texttt{teb\_local\_planner}中称为“扫射速度”(strafing velocity)。
	对于非完整类型(non-holonomic)的机器人（例如差动轮式机器人），应将$y$ velocity设置为零。
}



\section[Global Planner]{全局规划器}

\subsection[Global Planner Selection]{全局规划器的选择}

%To use the \texttt{move$\_$base} node in navigation stack, we need to have a global planner and a local planner. There are three global planners that adhere to \texttt{nav\_core::BaseGlobal\\Planner} interface: \texttt{carrot$\_$planner}, \texttt{navfn} and \texttt{global$\_$planner}.

要在导航堆栈中使用\texttt{move$\_$base}节点，需要配置一个全局规划器和一个局部规划器。ROS有三个全局规划器继承自\texttt{nav\_core::BaseGlobal\\Planner}接口：\texttt{carrot$\_$planner}，\texttt{navfn}和\texttt{global$\_$planner}。

\subsubsection{carrot\_planner}

%This is the simplest one. It checks if the given goal is an obstacle, and if so it picks an alternative goal close to the original one, by moving back along the vector between the robot and the goal point. Eventually it passes this valid goal as a plan to the local planner or controller (internally). Therefore, this planner does not do any global path planning. It is helpful if you require your robot to move close to the given goal even if the goal is unreachable. In complicated indoor environments, this planner is not very practical.

这是最简单的全局规划器。 
它检查给定的目标点是否在障碍区，如果目标点在障碍区，则沿机器人和目标点之间连线，在连线上选择一个最接近原始目标点的有效目标点。 
最终，它将该有效目标点直接传递给局部规划器或内容控制器。
所以，该规划器并没有进行任何的规划。
它在你需要移动机器人到给定目标点而且目标点无法到达的情况下很有用。
对于复杂的环境，该规划器并不实用。

\subsubsection[navfn and global\_planner]{navfn 和 global\_planner}

%\texttt{navfn} uses Dijkstra's algorithm to find a global path with minimum cost between start point and
%end point. \texttt{global$\_$planner} is built as a more flexible replacement of \texttt{navfn} with more options. These
%options include (1) support for A$*$, (2) toggling quadratic approximation, (3) toggling grid path. Both \texttt{navfn} and
%global planner are based on the work by \cite{brock1999high}:

\texttt{navfn} 采用 Dijkstra算法在起点和终点之间寻找一条最小代价的路径。
\texttt{global$\_$planner}是\texttt{navfn}的灵活性替代，提供了更多的选项，包括：
(1) 支持A$*$, (2) 二次近似的切换, (3) 栅格地图的切换。
\texttt{navfn} 和 \texttt{global$\_$planner}实现的内容都是基于\cite{brock1999high}的工作。

\subsection[Global Planner Parameters]{全局规划器的参数}

%Since \texttt{global\_planner} is generally the one that we prefer, let us look at some of its key parameters.
%Note: not all of these parameters are listed on ROS's website, but you can see them if you run the rqt dynamic reconfigure program: with \begin{center}
%	\texttt{rosrun rqt\_reconfigure rqt\_reconfigure}
%\end{center}
通常情况下我们更喜欢使用\texttt{global\_planner}，现在来看看它的一些关键参数。注意：并非所有的参数都在ROS的官网上罗列出来，但如果你运行rqt动态配置程序时你可以看到它们：
\begin{center}
	\texttt{rosrun rqt\_reconfigure rqt\_reconfigure}
\end{center}
可以让\texttt{allow\_unknown}(true), \texttt{use\_dijkstra}(true), \texttt{use\_quadratic}(true), \texttt{use\_grid\_path}(false), \texttt{old\_navfn\_behavior}(false)保留它们的默认参数。当需要在rviz可视化候选地图时将\texttt{visualize\_potential}(false)设置为true会带来很多帮助。

\begin{figure}[!htb]
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{Dijkstra.png}
	\caption{Dijkstra路径}
	\endminipage\hfill
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{AStar2.png}
	\caption{A* 路径}
	\endminipage\hfill
\end{figure}

\begin{figure}[!htb]
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{GlobalPlanner.png}
	\caption{标准行为}
	\endminipage\hfill
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{GridPath.png}
	\caption{栅格路径}
	\endminipage\hfill
\end{figure}


%Besides these parameters, there are three other unlisted parameters that actually determine the quality of the planned
%global path. 

除去这三个参数外，还有另外三个未列出的参数对规划全局路径的质量造成很大的影响。它们是\texttt{cost\_factor}, \texttt{neutral\_cost}, \texttt{lethal\_cost}。
实际上，这些参数也存在于\texttt{navfn}的配置中。
源程序\footnote{\scriptsize\url{https://github.com/ros-planning/navigation/blob/indigo-devel/navfn/include/navfn/navfn.h}}有一段描述解释了\texttt{navfn}是如何计算代价值的。

%They are \texttt{cost\_factor}, \texttt{neutral\_cost}, \texttt{lethal\_cost}. Actually, these parameters also present
%in \texttt{navfn}. The source code\footnote{\scriptsize\url{https://github.com/ros-planning/navigation/blob/indigo-devel/navfn/include/navfn/navfn.h}} \normalsize has one paragraph explaining how \texttt{navfn} computes cost values.
%
%\newpage

\begin{figure}[!htb]
	\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{Cf_lo.png}
	\caption{\texttt{cost\_factor} = 0.01}
	\endminipage\hfill
	\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{Cf_mid.png}
	\caption{\texttt{cost\_factor} = 0.55}
	\endminipage\hfill
	\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{Cf_hi.png}
	\caption{\texttt{cost\_factor} = 3.55}
	\endminipage\hfill
\end{figure}

\begin{figure}[!htb]
	\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{NC_lo.png}
	\caption{\texttt{neutral\_cost} = 1}
	\endminipage\hfill
	\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{NC_mid.png}
	\caption{\texttt{neutral\_cost} = 66}
	\endminipage\hfill
	\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{NC_hi.png}
	\caption{\texttt{neutral\_cost} = 233}
	\endminipage\hfill
\end{figure}

\newpage


\texttt{navfn} 的代价值设置为：

$$\texttt{cost = COST\_NEUTRAL + COST\_FACTOR * costmap\_cost\_value.}$$

传入costmap的代价值的范围为0到255。注释中提到：
%Incoming costmap cost values are in the range 0 to 252. The comment also says:
\begin{displayquote}
	%	With \texttt{COST\_NEUTRAL} of 50, the \texttt{COST\_FACTOR} needs to be about 0.8 to
	%	ensure the input values are spread evenly over the output range, 50
	%	to 253.  
	当\texttt{COST\_NEUTRAL}为50时，\texttt{COST\_FACTOR}需要设置为大约0.8以确保输入值均匀分布到50到253的输出范围内。
	如果 \texttt{COST\_FACTOR} 设置为更高的值，则代价值将稳定到障碍物的高度，规划器会不重视狭窄走廊的宽度，使得规划的路线并没有沿着中心下降。
	
	%	If \texttt{COST\_FACTOR} is higher, cost values will have a plateau
	%	around obstacles and the planner will then treat (for example) the
	%	whole width of a narrow hallway as equally undesirable and thus
	%	will not plan paths down the center.
\end{displayquote}

\paragraph[Experiment observations]{实验情况} %
%Experiments have confirmed this explanation. Setting \texttt{cost\_factor} to too low or too high lowers the quality of the paths. These paths do not go through the middle of obstacles on each side and have relatively flat curvature. Extreme \texttt{neutral\_cost} values have the same effect. For \texttt{lethal\_cost}, setting it to a low value may result in failure to produce any path, even when a feasible path is obvious. Figures $5-10$ show the effect of \texttt{cost\_factor} and \texttt{neutral\_cost} on global path planning. The green line is the global path produced by \texttt{global\_planner}.

该段解释在实验中得到了印证。将\texttt{cost\_factor}设置得太低或太高都会降低路径的质量。这些路径并不会穿过每侧障碍物的中间，并具有相对低较的曲率。
\texttt{neutral\_cost}的极端值具有相同的效果。
对于\texttt{lethal\_cost}，将其设置为较低的值可能导致无法生成任何路径，即使可行路径仍非常明显。图$5-10$显示了\texttt{cost\_factor} 和\texttt{neutral\_cost}在全局规划任务上的效果。其中绿线是\texttt{global\_planner}规划的全局路径。

%After a few experiments we observed that when \texttt{cost\_factor} = 0.55, \texttt{neutral\_cost = 66}, and \texttt{lethal\_cost = 253}, the global path is quite desirable.

经过几次试验后，我们看到，当\texttt{cost\_factor} = 0.55, \texttt{neutral\_cost = 66}, 和 \texttt{lethal\_cost = 253}时，生成的全局路径是意向中的路径。

\section[Local Planner Selection]{局部规划器的选择}

%Local planners that adhere to \texttt{nav\_core::BaseLocalPlanner} interface are \texttt{dwa\_local\\\_planner}, \texttt{eband\_local\_planner} and \texttt{teb\_local\_planner}.
%They use different algorithms to generate velocity commands. Usually \texttt{dwa\_local\_planner} is the go-to choice. We will discuss it in detail. More
%information on other planners will be provided later.

继承自\texttt{nav\_core::BaseLocalPlanner}的局部规划器的接口为\texttt{dwa\_local\\\_planner}, \texttt{eband\_local\_planner} 和 \texttt{teb\_local\_planner}。
它们使用不同的算法生成速度指令。
一般而言，首选\texttt{dwa\_local\_planner}。
我们将对它进行详细讨论。
以后将提供其他规划器的更多信息。

\subsection[DWA Local Planner]{DWA局部规划器}
\subsubsection[DWA algorithm]{DWA算法}

%\texttt{dwa\_local\_planner} uses Dynamic Window Approach (DWA) algorithm. ROS Wiki provides a summary of its implementation of this algorithm:

\texttt{dwa\_local\_planner}使用动态窗口(Dynamic Window Approach, DWA)算法。ROS的Wiki页面提供了该算法的实现总结：

%\begin{center}
%	\setlength{\fboxsep}{1em}
%	\fbox{\begin{minipage}{33 em}
%			\begin{enumerate}
%				\item Discretely sample in the robot's control space \textit{(dx,dy,dtheta)}
%				\item For each sampled velocity, perform forward simulation from the robot's current state to predict what would happen if the sampled velocity were applied for some (short) period of time.
%				\item Evaluate (score) each trajectory resulting from the forward simulation, using a metric that incorporates characteristics such as: proximity to obstacles, proximity to the goal, proximity to the global path, and speed. Discard illegal trajectories (those that collide with obstacles).
%				\item Pick the highest-scoring trajectory and send the associated velocity to the mobile base.
%				\item Rinse and repeat.
%			\end{enumerate}
%	\end{minipage}}
%\end{center}

\begin{center}
	\setlength{\fboxsep}{1em}
	\fbox{\begin{minipage}{33 em}
			\begin{enumerate}
				\item 在机器人的控制空间\textit{(dx,dy,dtheta)}进行离散采样。
				\item 对于每个采样速度，从机器人的当前状态执行正向模拟，预测使用该采样速度在某个（短）时间段内会发生什么情况。
				\item %利用包含有以下因子的度量来评估(计分)每个由前向模拟产生的轨迹：接近障碍物程序，接近目标程序，与全局路径的接近性
				使用含有以下因素的度量来评估（得分）每个前向模拟产生的轨迹：与障碍物的接近度，与目标点的接近度，全局路径的贴合度，及所使用的速度。 丢弃不合格的轨迹（与障碍物发生碰撞的轨迹）。
				\item 选择得分最高的轨迹并将相关的速度指令发送到移动基座。
				\item 冲洗(Rinse)并重复该过程。
			\end{enumerate}
	\end{minipage}}
\end{center}

%\noindent DWA is proposed by \cite{fox1997dynamic}. According to this paper, the goal of DWA is to produce a $(v,\omega)$ pair which represents a circular trajectory that is optimal for robot's local condition. DWA reaches this goal by searching the velocity space in the next time interval. The velocities in this space are restricted to be admissible, which means the robot must be able to stop before reaching the closest obstacle on the circular trajectory dictated by these admissible velocities. Also, DWA will only consider velocities within a dynamic window, which is defined to be the set of velocity pairs that is reachable within the next time interval given the current translational and rotational velocities and accelerations. DWA maximizes an objective
%function that depends on (1) the progress to the target, (2) clearance from obstacles, and (3) forward velocity to produce the optimal velocity pair.

DWA由\cite{fox1997dynamic}提出。根据论文描述，DWA的目标是产生一对$(v,\omega)$对，表示最适合机器人局部条件的圆形轨迹。DWA通过在下一个时间间隔中搜索速度空间来达到此目标。该空间中的速度被限制为允许的，这意味着机器人必须能够在到达由这些允许的速度决定的圆形轨迹上的最近障碍物之前停止。此外，DWA将仅考虑动态窗口内的速度，动态窗口被定义为在给定当前平移和旋转速度和加速度的情况下在下一时间间隔内可到达的速度对的集合。DWA最大化目标函数，其取决于（1）到目标的进展，（2）从障碍物的清除，以及（3）前向速度以产生最佳速度对。

Now, let us look at the algorithm summary on ROS Wiki. The first step is to sample velocity pairs $(v_x, v_y, \omega)$ in
the velocity space within the dynamic window. The second step is basically obliterating velocities (i.e. kill off bad trajectories) that are not admissible. The third step is
to evaluate the velocity pairs using the objective function, which outputs \textit{trajectory score}. The fourth and fifth steps are easy to understand: take the current best
velocity option and recompute.\\

我们看看ROS Wiki上的算法概要。第一步对在位于动态窗口内的速度空间中对速度对$(v_x, v_y, \omega)$进行采样。
第二步基本上是剔除不可用的速度(即消除不好的轨迹)。
第三步是利用目标函数评估得到的速度对，产生\emph{轨迹分数}。
第四步和第五步很容易理解：选择对当前状态最好的速度再重新计算。


This DWA planner depends on the local costmap which provides obstacle information. Therefore, tuning the parameters for the local costmap is crucial for optimal behavior of DWA local planner. Next, we will look at parameters in forward simulation, trajectory scoring, costmap, and so on.

DWA规划器依赖于提供障碍信息的代价图。因此，调整局部代价图的参数对于优化DWA局部规划器的行为至关重要。下面，
我们通过前向模拟、轨迹评分和代价图等看看相关的参数。


\subsubsection[DWA Local Planner : Forward Simulation]{DWA局部规划器：前向模拟}

%Forward simulation is the second step of the DWA algorithm. In this step, the local planner takes the velocity samples in robot's control space, and examine the circular trajectories represented by those velocity samples, and finally eliminate bad velocities (ones whose trajectory intersects with an obstacle). Each velocity sample is simulated as if it is applied to the robot for a set time interval, controlled by \texttt{sim\_time}($s$) parameter. We can think of \texttt{sim\_time} as the time allowed for the robot to move with the sampled velocities.

前向模拟是DWA算法的第二步。
在该步中，局部规划器将在机器人的控制空间中采样速度，检查由这些速度样本表示的圆形轨迹，最后消除不良速度(轨迹与障碍物相交的速度)。
在设置的时间间隔内，每个由参数 \texttt{sim\_time}(单位为$s$)速度被模拟为真实地应用到机器人上。
我们可以认为\texttt{sim\_time}是机器人在给定的采样速度下允许运行的时间。

%Through experiments, we observed that the longer the value of \texttt{sim\_time}, the heavier the computation load becomes. Also, when \texttt{sim\_time} gets 
%longer, the path produced by the local planner is longer as well, which is reasonable. Here are some suggestions on how to tune this \texttt{sim\_time} parameter.

通过实验，我们观察到仿真时间\texttt{sim\_time}越长，计算负荷越大。此外，当仿真时间\texttt{sim\_time}变大后，局部路径规划器产生的路径也会相应变长，这种现象是在合理范围内的。
这里有一些关于如何调整仿真时间参数\texttt{sim\_time}的建议。

\paragraph[How to tune \texttt{sim\_time}]{如何调整\texttt{sim\_time}}

%Setting \texttt{sim\_time} to a very low value ($<= 2.0$) will result in limited performance, especially when the robot needs to pass a narrow doorway, or gap between furnitures, because there is insufficient time to obtain the optimal trajectory that actually goes through the narrow passway. On the other hand, since with DWA Local Planner, all trajectories are simple arcs,
%setting the \texttt{sim\_time} to a very high value ($>= 5.0$) will result in long curves that are not very flexible. This problem is not that unavoidable,
%because the planner actively replans after each time interval (controlled by \texttt{controller\_frequency}($Hz$)), which leaves room for small adjustments. A value of 4.0 seconds should be enough even for high performance computers.


如果将仿真时间\texttt{sim\_time}的值设置为非常低（例如$\leq 2.0$）将导致性能下降，
尤其是当机器人需要通过狭窄的门口、或家具之间的间隙时。
这是因为没有足够多的时间进行计算以获得最佳轨迹以便通过狭窄的通道。
另一方面，由于使用了DWA规划器，所有的轨迹都是简单的圆弧，如果将仿真时间\texttt{sim\_time}设置的非常高（$\geq$5.0），将得到一条很长的缺乏灵活性能的曲线。该问题并不是不可避免的，因为规划器在每个时间间隔后都会主动进行重规划(由参数\texttt{controller\_frequency}(单位为$Hz$)控制)，它可以对结果进行一次较小的调整。
对于性能较高的计算机，4.0秒的计算时间足矣。


\begin{figure}[!htb]
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{simtime15.png}
	\caption{\texttt{sim\_time} = 1.5}
	\endminipage\hfill
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{simtime4.png}
	\caption{\texttt{sim\_time} = 4.0}
	\endminipage\hfill
\end{figure}

%Besides \texttt{sim\_time}, there are several other parameters that worth our attention.
除了仿真时间，还有几个参数值得注意。

%\paragraph{Velocity samples}
%Among other parameters, \texttt{vx\_sample}, \texttt{vy\_sample} determine how many translational velocity samples to take in x, y direction. \texttt{vth\_sample} controls the number of rotational velocities samples. The number of samples you would like to take depends on how much computation power you have. In most cases we prefer to set \texttt{vth\_samples} to
%be higher than translational velocity samples, because turning is generally a more complicated condition than moving straight ahead. If you set \texttt{max\_vel\_y} to be zero,
%there is no need to have velocity samples in y direction since there will be no usable samples. 
%We picked \texttt{vx\_sample} = 20, and \texttt{vth\_samples} = 40.

\textbf{速度采样}：在其它几个参数中，
\texttt{vx\_sample}和\texttt{vy\_sample}分别决定在x和y方向上进行速度采样时平移部分的量。
\texttt{vth\_sample}控制速度采样中旋转部分的量。
速度采样的数量取决于你的设备的计算能力。
多数情况下，我们倾向于设置\texttt{vth\_samples}的值大于平移部分的值，原因在于通常情况下旋转要比直线前进更为复杂。
如果将\texttt{max\_vel\_y}设置为零，因为没有可用信息所以没必要在y方向提取速度样本。
我们设置\texttt{vx\_sample} = 20, \texttt{vth\_samples} = 40。


%\paragraph{Simulation granularity}
%\texttt{sim\_granularity} is the step size to take between points on a trajectory. It basically means how frequent should the points on this trajectory be examined (test if they intersect with any obstacle or not). A lower value means higher frequency, which requires more computation power. The default value of 0.025 is generally enough for turtlebot-sized mobile base.

\textbf{仿真粒度}：\texttt{sim\_granularity}意为在轨迹上的采样点之间的步长。
该参数含义为需要多频繁的检查轨迹上的点（检测它们是否与障碍物相交）。
较低的值意味着高频率，当然需要更多的计算性能。
对于turtlebot这类机器人来说，默认值0.025足够胜任。

\subsubsection[DWA Local Planner: Trajactory Scoring]{DWA局部规划器：轨迹得分}
%{DWA Local Planner : Trajactory Scoring}

%As we mentioned above, DWA Local Planner maximizes an objective function to obtain optimal velocity pairs. In its paper, the value of this objective function relies on three
%components: progress to goal, clearance from obstacles and forward velocity. In ROS's implementation, the cost of the objective function is calculated like this:
如上所述，DWA规划器通过最大化目标函数来获得最佳速度对。
在DWA的论文中，目标函数的值依赖于三部分：到目标点的过程、清除障碍物和前进速度。在ROS中，目标函数的计算公式如下：

\begin{eqnarray*}\footnotesize
	cost &=& \texttt{path\_distance\_bias} * (\text{distance($m$) to path from the endpoint of the trajectory})\\
	&+& \texttt{goal\_distance\_bias} * (\text{distance($m$) to local goal from the endpoint of the trajectory})\\
	&+& \texttt{occdist\_scale} * (\text{maximum obstacle cost along the trajectory in obstacle cost (0-254)})
\end{eqnarray*}

%\normalsize
%\noindent The objective is to get the lowest cost. \texttt{path\_distance\_bias} is the weight for how much the local planner should stay close to the global path \cite{furrer2016robot}. A high value will make the local planner prefer trajectories
%on global path. 

目标函数的意义在于获得最小的行走代价。
\texttt{path\_distance\_bias}为局部规划器以多大权重与全局路径保持一致\cite{furrer2016robot}。
较大值将使局部规划器倾向于跟踪全局路径。

%\texttt{goal\_distance\_bias} is the weight for how much the robot should attempt to reach the local goal, with whatever path. Experiments show that increasing this
%parameter enables the robot to be less attached to the global path.
\texttt{goal\_distance\_bias}衡量机器人无论走哪条路径应该以多大权重尝试到达目标点。
实验显示增加\texttt{goal\_distance\_bias}的值会使机器人与全局路径的一致性保持度偏低。

%\texttt{occdist\_scale} is the weight for how much the robot should attempt to avoid obstacles. A high value for this
%parameter results in indecisive robot that stucks in place. Currently for SCITOS G5, we set \texttt{path\_distance\_bias} to 32.0, \texttt{goal\_distance\_bias} to 20.0, \texttt{occdist\_scale} to 0.02. They work well in simulation.

\texttt{occdist\_scale}是权衡机器人以多大的权重躲避障碍物。该值过大会导致机器人陷入困境。

在SCITOS G5上，我们设置 \texttt{path\_distance\_bias}为32，\texttt{goal\_distance\_bias}为20，\texttt{occdist\_scale} 为0.02，仿真结果良好。


\subsubsection[DWA Local Planner: Other Parameters]{DWA局部规划器：其他参数}%{DWA Local Planner : Other Parameters}

\paragraph{Goal distance tolerance} These parameters are straightforward to understand. Here we will list their description shown on ROS Wiki:
目标距离容差(Goal distance tolerance)：这些参数很直观，以下为它们在ROS Wiki上的描述：

\begin{itemize}
	\item \texttt{yaw\_goal\_tolerance} (double, 默认值: 0.05，单位：弧度)
	%The tolerance in radians for the controller in yaw/rotation when achieving its goal.
	到达目标点时，偏航/旋转中控制器的弧度容差(tolerance)。
	
	\item \texttt{xy\_goal\_tolerance} (double, 默认值: 0.10，单位：米)
	%The tolerance in meters for the controller in the x \& y distance when achieving a goal.
	到达目标点时，控制器在x \& y方向的距离容差，单位为米。
	
	\item \texttt{latch\_xy\_goal\_tolerance} (bool, 默认值: false) 
	%If goal tolerance is latched, if the robot ever reaches the goal xy location it will simply rotate in place, even if it ends up outside the goal tolerance while it is doing so.
	目标容差被锁定情况下，机器人到达目标的xy位置时会简单旋转到位；
	如果机器人在目标容差(goal tolerance)范围之外进入结束状态时，也会简单旋转到位。
	
\end{itemize}


%\paragraph{Oscilation reset} In situations such as passing a doorway, the robot may oscilate back and forth because its local planner is producing paths leading to two opposite directions. If the robot keeps oscilating, the navigation stack will let the robot try its recovery behaviors.

\textbf{振荡复位}（Oscilation reset）：
在诸如通过门口情况下，机器人可能会来回振荡，因为其局部规划器正在产生通过两个相反方向的路径。如果机器人保持振荡，导航功能包将让机器人尝试恢复行为。

\begin{itemize}
	\item \texttt{oscillation\_reset\_dist} (double, 默认值: 0.05， 单位：米) 
	%How far the robot must travel in meters before oscillation flags are reset.
	在振荡标志复位前，机器人必须以米为单位行走多远。
\end{itemize}



\section[Costmap Parameters]{代价地图参数}
%{Costmap Parameters}

%As mentioned above, \textit{costmap} parameters tuning is essential for the success of local planners (not only for DWA). In ROS, costmap is composed of static map layer, obstacle map layer and inflation layer. 
%Static map layer directly interprets the given static SLAM map provided to the navigation stack. Obstacle map layer includes 2D obstacles and 3D obstacles (voxel layer). Inflation layer is where obstacles are inflated to calculate cost for each 2D costmap cell.
如上所述，代价地图参数对于本地规划器（不仅仅是DWA）是至关重要的。在ROS中，代价地图由静态地图层、障碍物图层和膨胀层组成。
静态地图层直接给导航堆栈提供静态SLAM地图解释。
障碍物图层包含2D障碍物和3D障碍物（体素层）。
膨胀层是将障碍物膨胀来计算每个2D代价地图单元的代价。

如上所述，调整\textit{costmap}代价地图参数对于局部规划器（不仅仅是DWA）的成功至关重要。 
在ROS中，costmap由静态地图层(static map layer)，障碍地图层(obstacle map layer)和膨胀层(inflation layer)组成。 
静态地图层对提供给导航功能包的静态SLAM地图直接进行解释。 
障碍层包括有2D的障碍物和3D的障碍物（体素层）。 
膨胀层将障碍物进行膨胀以计算每个2D代价单元(cell)的通行代价。

%Besides, there is a \textit{global costmap}, as well as a \textit{local costmap}. Global costmap is generated by inflating the obstacles on the map provided to the navigation stack. Local costmap is generated
%by inflating obstacles detected by the robot's sensors in real time. 

此外，还存在全局代价地图(\textit{global costmap})，和局部代价地图(\textit{local costmap})。
全局代价地图通过膨胀导航功能包的地图上已存在的障碍物产生。
局部代价地图通过将机器人传感器检测到的障碍物进行膨胀产生的。

\begin{figure}[!h]
	\includegraphics[width=\linewidth]{costmapspec.png}
	\caption{膨胀衰减}
\end{figure}

%\noindent There are a number of important parameters that should be set as good as possible.
\noindent 此外还有很多重要的参数应尽可能设置好。

\subsection[footprint]{足印}%{footprint} 
Footprint is the contour of the mobile base. In ROS, it is represented by a two dimensional array of the form $[x_0, y_0],[x_1,y_1],[x_2,y_2],...]$, no need to repeat the first coordinate. This footprint will be used to compute the radius of inscribed circle and circumscribed circle, which are used to inflate obstacles in a way that fits this robot. Usually for safety, we want to have the footprint to be slightly larger than the robot's real contour.

足印(footprint)是机器人移动本体的轮廓。
在ROS中，footprint由二维数组表示 $[x_0, y_0], [x_1,y_1], [x_2,y_2], ...]$，无需重复第一个坐标。
footprint用于计算内切圆和外接圆的半径，以确定适合该机器人的方式对障碍物进行膨胀。
为安全起见，我们通常将footprint设置为略大于机器人的真实轮廓。

To determine the footprint of a robot, the most straightforward way is to refer to the drawings of your robot. Besides, you can manually take a picture of the top view of its base. Then use CAD software (such as Solidworks) to scale the image appropriately and move your mouse around the contour of the base and read its coordinate. The origin of the coordinates should be the center of the robot. Or, you can move your robot on a piece of large paper, then draw the contour of the base. Then pick some vertices and use rulers to figure out their coordinates.

要确定机器人的footprint，最直接的方法是参考机器人的图纸。 
此外，您可以手工拍摄其基座俯视图。 然后使用CAD软件（例如Solidworks）适当缩放图像，并将鼠标移动到基座轮廓周围并读取其坐标。 
坐标原点应为机器人的中心。 
或者，您可以将机器人移动到一张大纸上，然后绘制基座的轮廓。 然后选择一些顶点并使用标尺来确定它们的坐标。

\subsection[inflation]{膨胀}%{inflation} 
Inflation layer is consisted of cells with cost ranging from 0 to 255. Each cell is either occupied, free of obstacles, or unknown. Figure 13 shows a diagram \footnote{Diagram is from \url{http://wiki.ros.org/costmap_2d}} illustrating how inflation decay curve is computed.
膨胀层(Inflation layer)由代价值位于0到255的单元(cell)组成。每个单元可能会被占据(occupied)、无障碍或未知三种情况。
图13的图表\footnote{图表来自\url{http://wiki.ros.org/costmap_2d}}说明了如何计算膨胀衰减曲线的过程。


%\texttt{inflation\_radius} and \texttt{cost\_scaling\_factor} are the parameters that determine the inflation. \texttt{inflation\_radius} controls how far away the zero cost point is from the obstacle. \texttt{cost\_scaling\_factor} is inversely proportional to the cost of a cell. Setting it higher will make the decay curve more steep.

\texttt{inflation\_radius}和texttt{cost\_scaling\_factor}是决定膨胀的主要参数。
\texttt{inflation\_radius}控制零代价点距离障碍物有多远。
\texttt{cost\_scaling\_factor}与单元(cell)的代价值成反比，设置高值将使衰减曲线更为陡峭。

Dr. Pronobis sugggests the optimal costmap decay curve is one that has relatively low slope, so that the best path is as far as possible from the obstacles on each side. The advantage is that the robot would prefer to move in the middle of obstacles.  As shown in Figure 8 and 9, with the same starting point and goal, when costmap curve is steep, the robot tends to be close to obstacles. In Figure 14, \texttt{inflation\_radius} = 0.55, \texttt{cost\_scaling\_factor} = 5.0; In Figure 15, \texttt{inflation\_radius} = 1.75, \texttt{cost\_scaling\_factor} = 2.58

Pronobis博士认为，最佳代价图的衰减曲线应为斜率相对较低的曲线，这样可使得最佳路径尽可能远离每侧的障碍物。
优点是机器人更趋向于在障碍物中间移动。
如图8和图9所示，在具有相同的起点和目标点情况下，当代价图的曲线非常陡峭时，机器人往往会靠近障碍物。
在图14中，膨胀半径\texttt{inflation\_radius} = 0.55，代价比例因子\texttt{cost\_scaling\_factor} = 5.0；在图15中，膨胀半径\texttt{inflation\_radius} = 1.75，代价比例因子\texttt{cost\_scaling\_factor} = 2.58。

\begin{figure}[!htb]
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{notgoodinflation.png}
	\caption{steep inflation curve}
	\endminipage\hfill
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{goodinflation.png}
	\caption{gentle inflation curve}
	\endminipage\hfill
\end{figure}

%Based on the decay curve diagram, we want to set these two parameters such that the inflation radius almost covers the corriders, and the decay of cost value is moderate, which means decrease the value of \texttt{cost\_scaling\_factor} .

根据衰变曲线图，我们需设定这两个参数值，以使得膨胀半径几乎覆盖走廊，并且代价值的衰减速度相对中等，这意味着要降低代价的比例因子\texttt{cost\_scaling\_factor}的值。

\subsection[costmap resolution]{代价地图的分辨率}%{costmap resolution} 
%This parameter can be set separately for local costmap and global costmap. They affect computation load and path planning. With low resolution ($>=0.05$), in narrow passways, the obstacle region may overlap and thus the local planner will not be able to find a path through.
可以在局部代价图和全局代价图单独设置此参数。它们影响着计算设备的计算负荷和规划器的路径规划能力。
对于低分辨率($>=0.05$)，在狭窄的通道中，障碍物区域可能会重叠，导致局部规划器无法找到可通行路径。

%For global costmap resolution, it is enough to keep it the same as the resolution of the map provided to navigation stack. If you have more than enough computation power, you should take a look at the resolution of your laser scanner, because when creating the map using gmapping, if the laser scanner has lower resolution than your desired map resolution, there will be a lot of small "unknown dots" because the laser scanner cannot cover that area, as in Figure 10.

对于全局代价图的分辨率，只要其与导航功能包的地图的分辨率保持相同即可。
如果有足够的计算能力，可以查看激光扫描仪的分辨率，因为当使用gmapping建图时，如果激光扫描仪的分辨率低于所需的地图分辨率，则会有很多小的“未知点”，因为激光扫描仪无法覆盖该区域，如图10所示。


\begin{figure}[!h]
	\begin{center}
		\includegraphics[width=22em]{resolutionholes.png}
		\caption{gmapping分辨率= 0.01。 注意图像右侧的未知点}
		%{gmapping resolution = 0.01. Notice the unknown dots on the right side of the image}
	\end{center}
\end{figure}

%For example, Hokuyo URG-04LX-UG01 laser scanner has metric resolution of 0.01mm\footnote{data from \url{https://www.hokuyo-aut.jp/02sensor/07scanner/download/pdf/URG-04LX_UG01_spec_en.pdf}}. Therefore, scanning a map with resolution $<=0.01$ will require the robot to rotate several times in order to clear unknown dots. We found 0.02 to be a sufficient resolution to use.
例如，Hokuyo URG-04LX-UG01激光扫描仪的分辨率是0.01mm\footnote{数据来源： \url{https://www.hokuyo-aut.jp/02sensor/07scanner/download/pdf/URG-04LX_UG01_spec_en.pdf}}，因此建立扫描分辨率为$\leq 0.01$的地图需要多旋转机器人几次才能清除未知的点。
可以发现，0.02的分辨率就够用了。

\subsection[obstacle layer and voxel layer]{障碍物层和体素层}
%{obstacle layer and voxel layer} 
%These two layers are responsible for marking obstacles on the costmap. They can be called altogether as \textit{obstacle layer}. According to ROS wiki, the obstacle layer tracks in two dimensions, whereas the voxel layer tracks in three. Obstacles are marked (detected) or cleared (removed) based on data from robot's sensors, which has topics for costmap to subscribe to.

这两个图层负责在代价图上标注障碍物。它们可以被称为障碍层(\textit{obstacle layer})。根据ROS wiki的介绍，障碍层在两个维度上进行跟踪，而体素层在三个维度上进行跟踪。障碍物是根据机器人传感器的数据进行标记（检测）或清除（删除）建立的，
同时为代价图提供了订阅的主题(topics)。

%In ROS implementation, the voxel layer inherits from obstacle layer, and they both obtain obstacles information by interpreting laser scans or data sent with \texttt{PointCloud} or \texttt{PointCloud2} type messages. Besides, the voxel layer requires depth sensors such as Microsoft Kinect or ASUS Xtion. 3D obstacles are eventually projected down to the 2D costmap for inflation.
%在ROS的实现代码中，体素层继承自障碍物层，并且都是通过使用激光雷达发布的PointCloud或PointCloud2类型的消息来获取障碍物信息。此外，体素层需要深度传感器，如Microsoft Kinect或华硕Xtion，3D障碍物最终会被膨胀为二维代价图。

在ROS的实现代码中，体素层继承自障碍物层，两者皆为通过解释激光扫描(laser scans)或使用\texttt{PointCloud}和\texttt{PointCloud2}类型的消息发送数据获取障碍物的信息。 此外，体素层需要深度传感器，如Microsoft Kinect或ASUS Xtion。 3D障碍物最终会被膨胀为二维代价图。

\paragraph{How voxel layer works} Voxels are 3D volumetric cubes (think 3D pixel) which has certain relative position in space. It can be used to be associated with data or properties of the volume near it, e.g. whether its location is an obstacle. There has been quite a few research around online 3D reconstruction with the depth cameras via voxels. Here are some of them.

\textbf{体素层如何工作}：
体素是空间中具有一定相对位置的3D立方体（想象为3D像素）。它用于与其附近的数据或属性进行关联。例如，它的位置是否为一个障碍。
与体素与深度相机相关的3D重建已经有很多研究了。
已经存在很多通过深度相机获取体素进行在线3D重建的研究了。这是其中的一部分。

\begin{itemize}
	\item \href{http://delivery.acm.org/10.1145/2050000/2047270/p559-izadi.pdf?ip=128.208.7.188&id=2047270&acc=ACTIVE\%20SERVICE&key=B63ACEF81C6334F5\%2EF43F328D6C8418D0\%2E4D4702B0C3E38B35\%2E4D4702B0C3E38B35&CFID=830915711&CFTOKEN=23054788&__acm__=1472349664_9fd28ae246d72a507f6a93c5ac84a516}{KinectFusion: Real-time 3D Reconstruction and Interaction Using a Moving Depth Camera} 
	\item \href{https://people.mpi-inf.mpg.de/~mzollhoef/Papers/SGASIA2013_VH/paper.pdf}{Real-time 3D Reconstruction at Scale using Voxel Hashing}
	% \item \href{https://www.ri.cmu.edu/pub_files/2014/6/VoxelCarving.pdf}{Object Modeling and Recognition from Sparse, Noisy Data via Voxel Depth Carving}
\end{itemize}

%\texttt{voxel\_grid} is a ROS package which provides an implementation of efficient 3D voxel grid data structure that stores voxels with three states: marked, free, unknown. The \textit{voxel grid} occupies the volume within the costmap region. During each update of the voxel layer's boundary, the voxel layer will mark or remove some of the voxels in the voxel grid based on observations from sensors. It also performs ray tracing, which is discussed next. Note that the voxel grid is not recreated when updating, but only updated unless the size of local costmap is changed.

体素网格\texttt{voxel\_grid}是一个ROS包，它提供了一个高效的三维体素网格数据结构的实现，该存储了体素的三种状态：标记状态(marked)、自由状态(free)、未知状态(unknown)。\texttt{voxel\_grid}占据了代价地图区域内的体积。
在每次更新体素边界期间，体素层根据传感器的数据来标记或移除体素网格中的一些体素。
它还执行光线跟踪(ray tracing)作用，该内容将在接下来进行讨论。
请注意，体素层在更新时，不会重新创建体素网格；仅在更改局部代价图的尺寸大小时体素层才进行更新。

%\texttt{voxel\_grid}是一个ROS包，提供高效3D体素网格数据结构的实现，该结构存储具有三种状态的体素：标记，自由，未知。 \ textit {voxel grid}占据costmap区域内的卷。 在体素层边界的每次更新期间，体素层将基于来自传感器的观察来标记或移除体素网格中的一些体素。 它还执行光线跟踪，下面将对此进行讨论。 请注意，更新时不会重新创建体素网格，但只有在更改本地成本映射的大小时才会更新。

%\paragraph{Why ray tracing} 
in obstacle layer and voxel layer? Ray tracing is best known for rendering realistic 3D graphics, so it might be confusing why it is used in dealing with obstacles. One big reason is that obstacles of different type can be detected by robot's sensors. Take a look at figure 17. In theory, we are also able to know if an obstacle is rigid or soft (e.g. grass)\footnote{ mentioned in \textit{Using Robots in Hazardous Environments} by Boudoin, Habib, pp.370}.

为什么要在障碍物层或体素层进行光线跟踪？
光线跟踪以渲染逼真的3D图形而闻名，因此读者可能会对为什么将它用于处理障碍物这个问题而倍感困惑。
一个重要的原因是可以通过机器人的传感器检测不同类型的障碍物。
请观察图17。
理论上，我们还可以知道障碍物是刚性的还是柔性的(例如草)\footnote{出处为：\textit{Using Robots in Hazardous Environments}, Boudoin, Habib, pp.370。}。

\begin{figure}[!h]
	\begin{center}
		\includegraphics[width=23em]{ObstacleTypes.png}
		\caption{通过光线跟踪，激光扫描仪能够识别不同类型的障碍物。}
		%{With ray tracing, laser scanners is able to recognize different types of obstacles.}
	\end{center}
\end{figure}

%A good blog on voxel ray tracing versus polygong ray tracing:
一个关于体素光线跟踪对比多声源追踪的好博客：
\url{http://raytracey.blogspot.com/2008/08/voxel-ray-tracing-vs-polygon-ray.html} 

通过以上的解释，我们来研究一下障碍物层的一些参数\footnote{个别解释直接拷贝自ROS Wiki对costmap2d的介绍}。这些参数属于全局滤波参数，对所有的传感器都是适用的。

%With the above understanding, let us look into the parameters for the obstacle layer\footnote{Some explanations are directly copied from costmap2d ROS Wiki}. These parameters are global filtering parameters that apply to all sensors.

\begin{itemize}
	\item \texttt{max\_obstacle\_height}: 
	%	The maximum height of any obstacle to be inserted into the costmap in meters. This parameter should be set to be slightly higher than the height of your robot. For voxel layer, this is basically the height of the voxel grid.
	以米为单位插入代价图中的障碍物的最大高度。该参数应设置为略高于机器人的最大高度。对于体素层，这本质含义是指体素网格的高度。
	
	\item \texttt{obstacle\_range}: 
	%	The default maximum distance from the robot at which an obstacle will be inserted into the cost map in meters. This can be over-ridden on a per-sensor basis.
	插入代价地图的障碍物应距离机器人的最大默认距离，以米为单位。它可以在每个传感器的基础上进行覆盖操作。
	
	\item \texttt{raytrace\_range}: 
	%The default range in meters at which to raytrace out obstacles from the map using sensor data. This can be over-ridden on a per-sensor basis.
	%用于使用传感器数据在地图中扫描出障碍物，以米为单位，可以在每个传感器的基础上进行覆盖
	使用传感器数据从地图中光线追踪障碍物的默认范围（以米为单位）。 同样，该值可以在每个传感器的基础上被覆盖。
	
\end{itemize}

%These parameters are only used for the voxel layer (VoxelCostmapPlugin).
下面的这些参数仅适用于体素层(VoxelCostmapPlugin)
\begin{itemize}
	\item \texttt{origin\_z}: 
	%The z origin of the map in meters.
	地图的Z轴原点，以米为单位
	\item \texttt{z\_resolution}: 
	%	The z resolution of the map in meters/cell.
	地图的Z轴分辨率，以\emph{米/单元格}(meters/cell)为单位。
	
	\item \texttt{z\_voxels}: 
	%	The number of voxels to in each vertical column, the height of the grid is z\_resolution * z\_voxels.
	每个垂直列中的体素数目，网格的高度为z\_resolution * z\_voxels。
	
	\item \texttt{unknown\_threshold}: 
	The number of unknown cells allowed in a column considered to be "known"
	整列认为是“已知”(``known'')的时候，含有的未知单元(“unknown”)的最大数量。
	
	\item \texttt{mark\_threshold}: 
	%	The maximum number of marked cells allowed in a column considered to be "free".
	%	在被认为是“自由”的列中允许的标记单元的最大数量
	整列被认为是“自由”("free")的时候，含有的标记单元(“marked”)的最大数目。
	
\end{itemize}

\paragraph[Experiment observations]{实验观察情况}%{Experiment observations} 

Experiments further clarify the effects of the voxel layer's parameters.  We use ASUS Xtion Pro as our depth sensor. We found that position of Xtion matters in that it determines the range of "blind field", which is the region that the depth sensor cannot see anything. 

%实验观察：
%实验进一步阐明了体素层参数的影响。我们使用华硕Xtion Pro作为我们的深度传感器。我们发现Xtion的位置很重要，它决定了“盲区的范围”，即深度传感器看不到的区域。
实验进一步阐明了体素层参数的影响。我们使用ASUS Xtion Pro作为深度传感器。 我们发现Xtion的位置很重要，它决定了“盲区”的范围，即深度传感器看不到任何东西的区域。

%In addition, voxels representing obstacles only update (marked or cleared) when obstacles appear within Xtion range. Otherwise, some voxel information will remain, and their influence on costmap inflation remains. 
此外，当障碍物出现在Xtion的范围内时，表示障碍物的体素才会进行更新（标记或清除）。
否则，一些体素的信息仍保持不变，在代价地图中的膨胀信息也会保留。

Besides, \texttt{z\_resolution} controls how dense the voxels is on the $z$-axis. If it is higher, the voxel layers are denser. If the value is too low (e.g. 0.01), all the voxels will be put together and thus you won't get useful costmap information. If you set z\_resolution to a higher value, your intention should be to obtain obstacles better, therefore you need to increase \texttt{z\_voxels} parameter which controls how many voxels in each vertical column. It is also useless if you have too many voxels in a column but not enough resolution, because each vertical column has a limit in height. Figure 18-20 shows comparison between different voxel layer parameters setting.

另外，Z轴分辨率 \texttt{z\_resolution} 灰顶Z轴体素的密度。如果值很高，体素层会很密集。
如果值太低（例如0.01），所有的体素将被放在一起，将不会获得有效的代价图信息。如果将Z轴分辨率设置为较高的值，意图是更好地获得障碍物，因此需要增加Z轴体素数（该参数控制每个垂直列中的体素数）。如果列中的体素数太多但分辨率不够也是没用的，因为每个垂直列的高度都有限制。图18-20显示了不同体素参数设置之间的比较。

另外，Z轴的分辨率参数\texttt{z\_resolution}控制体素在$ z $-轴上的密度。 如果值很高，则体素层会更密集。 
如果该值太低（例如0.01），则所有体素将被放在一起，因此您将无法获得有用的代价图信息。 
如果将\texttt{z\_resolution}设置为更高的值，您的愿望应该是更好地获得障碍，因此您需要增加\texttt{z\_voxels}参数来控制每个垂直列中的体素数。 如果列中的体素太多但分辨率不够会导致设置不起作用，因为每个垂直列的高度都有限制。 
图18-20展示了设置不同的体素层参数进行比较的效果。

\begin{figure}[!h]
\end{figure}

\begin{figure}[!h]
	\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{voxellayerscene.png}
	\caption{场景：植物在机器人前面}
	\endminipage\hfill
	\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{voxellayerparam1.png}
	\caption{较高的\texttt{z\_resolution}}
	\endminipage\hfill
	\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{voxellayerparam2.png}
	\caption{较低的\texttt{z\_resolution}}
	\endminipage\hfill
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section[AMCL]{AMCL}

%\texttt{amcl} is a ROS package that deals with robot localization. It is the abbreviation of Adaptive Monte Carlo Localization (AMCL), also known as partical filter localization. This localization technique works like this: Each sample stores a position and orientation data representing the robot's pose. Particles are all sampled randomly initially. When the robot moves, particles are resampled based on their current state as well as robot's action using recursive Bayesian estimation.

\texttt{amcl} 是一个处理机器人定位的ROS包。 它是Adaptive Monte Carlo Localization（自适应蒙特卡罗, AMCL）的缩写，也称为粒子滤波(partical filter)定位器。 这种定位技术的工作原理如下：每个样本都存储一个表示机器人姿态的位置和方向数据。 
粒子在开始状态时都是随机采样的。 
当机器人移动时，粒子将根据其当前状态以及机器人的动作使用递归贝叶斯估计(recursive Bayesian estimation)进行重新采样。

%More discussion on AMCL parameter tuning will be provided later. Please refer to \url{http://wiki.ros.org/amcl} for more information. For the details of the original algorithm Monte Carlo Localization (MCL), read Chapter 8 of \textit{Probabilistic Robotics} \cite{thrun2005probabilistic}.\\

稍后将提供更多关于调整AMCL参数的讨论。请参考ROS维基\url{http://wiki.ros.org/amcl}以了解更多信息。关于原始Monte Carlo Localization (蒙特卡罗，MCL)的算法细节，阅读由Thrun, Burgard, 和 Fox所著的《概率机器人》(《Probabilistic Robotics》第八章\cite{thrun2005probabilistic}。

%\noindent We now summarize several issues that may affect the quality of AMCL localization\footnote{Added on April 8th, 2019. This investigation was done in May, 2017, yet not reported in this guide at the time.}.  We hope this information makes this guide more complete, and you find it useful.

我们现在总结一些可能影响AMCL定位质量的问题\footnote{于2019年4月8日增加。此指南于2017年5月完成，当时未在本指南中报告该部分内容。}。 我们希望此信息能够使本指南更加完整，并且您觉得有用。

\begin{figure}[!tb]
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{scanner1.png}
	\caption{当\texttt{LaserScan} 字段不正确时}
	%{When \texttt{LaserScan} fields are not correct}
	\label{fig:scanner1}
	\endminipage\hfill
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{scanner2.png}
	\caption{当\texttt{LaserScan} 字段正确时}
	%{When \texttt{LaserScan} fields are correct}
	\label{fig:scanner2}
	\endminipage\hfill
\end{figure}

Through experiments, we observed three issues that affect the localization with AMCL. As described in \cite{thrun2005probabilistic}, MCL maintains two probabilistic models, a \emph{motion model} and a \emph{measurement model}. In ROS \texttt{amcl}, the motion model corresponds to a model of the odometry, while the measurement model correspond to a model of laser scans. With this general understanding, we describe three issues separately as follows. 


通过实验，我们观察到三个影响AMCL定位的问题。 正如\cite{thrun2005probabilistic}中所述，MCL维护两个概率模型，
一个\emph{运动模型}(motion)和一个\emph{测量模型}(measurement)。 
在ROS的\texttt{amcl}中，运动模型对应于里程计的模型，而测量模型对应于激光扫描的模型。 
通过这种理解，我们分别描述了三个问题归结如下。

\subsection[Header in \texttt{LaserScan} messages]{\texttt{LaserScan}的头部结构问题}%{Header in \texttt{LaserScan} messages}

Messages that are published to \texttt{scan} topic are of type \texttt{sensor\_msgs/LaserScan}\footnote{See: \url{http://docs.ros.org/melodic/api/sensor_msgs/html/msg/LaserScan.html}}. This message contains a header with fields dependent on the specific laser scanner that you are using. These fields include (copied from the message documentation)

发布到\texttt{scan}主题的消息类型为\texttt{sensor\_msgs/LaserScan}\footnote{请参阅：\url{http://docs.ros.org/melodic/api/sensor_msgs/html/msg/LaserScan.html}}。此消息包含一个header部分，其字段取决于您所使用的具体的激光扫描仪。这些字段包括（以下内容摘自该消息的说明文档）

\begin{itemize}
	\item \texttt{angle\_min} (float32) scan的开始角度 [弧度] % [单位：rad (弧度)] %start angle of the scan [rad]
	\item \texttt{angle\_max} (float32) scan的结束角度 [弧度] %[单位：rad (弧度)]  %end angle of the scan 
	\item \texttt{angle\_increment} (float32) 测量的角度间的距离 [弧度] % start angle of the scan [rad]
	\item \texttt{time\_increment} (float32) 测量间的时间 [秒] -- 如果扫描仪在移动，这将用于插入3D点的位置 %time between measurements [seconds] - if your scanner is moving, this will be used in interpolating position of 3d points
	\item \texttt{scan\_time} (float32) 扫描间的时间 [秒] %time between scans [seconds]
	\item \texttt{range\_min} (float32) 最小的测量距离 [米]%minimum range value [m]
	\item \texttt{range\_max} (float32) 最大的测量距离 [米] %maximum range value [m]
	
	\item \texttt{ranges} (float32 [])  测量的距离数据 [米] (注意: 值 < range\_min 或 > range\_max 应当被丢弃)
	\item \texttt{intensities} (float32 []) 强度数据 [与设备相关的单位]
\end{itemize}

%We observed in our experiments that if these values are not set correctly for the laser scanner product on board, the quality of localization will be affected (see Figure~\ref{fig:scanner1} and \ref{fig:scanner2}. We have used two laser scanners products, the SICK LMS 200 and the SICK LMS 291. We provide their parameters below\footnote{For LMS 200, thanks to {this Github issue} (\url{https://github.com/smichaud/lidar-snowfall/issues/1})}.

我们在实验中观察到，如果没有为机器人身上的激光扫描仪正确设置这些参数的值，将影响定位的质量
（参见图〜\ref{fig：scanner1}和\ref{fig：scanner2}。我们使用了两个激光扫描仪，SICK LMS 200和SICK LMS 291。我们提供它们的参数如下\footnote{对对于LMS 200，感谢该\emph{Github}的问题（\url{https://github.com/smichaud/lidar-snowfall/issues/1}）}。

\noindent SICK LMS 200:
%\lstset{language=json}
%\begin{lstlisting}
%{   
%"range_min": 0.0,
%"range_max": 81.0,
%"angle_min": -1.57079637051,
%"angle_max": 1.57079637051,
%"angle_increment": 0.0174532923847,
%"time_increment": 3.70370362361e-05,
%"scan_time": 0.0133333336562
%}
%\end{lstlisting}

\noindent SICK LMS 291:
%\lstset{language=json}
%\begin{lstlisting}
%{   
%"range_min": 0.0,
%"range_max": 81.0,
%"angle_min": -1.57079637051,
%"angle_max": 1.57079637051,
%"angle_increment": 0.00872664619235,
%"time_increment": 7.40740724722e-05,
%"scan_time": 0.0133333336562
%}
%\end{lstlisting}


\subsection[Parameters for measurement and motion models]{测量和运动模型的参数问题}
There are parameters listed in the \texttt{amcl} package about tuning the laser scanner model (measurement)  and odometry model (motion). Refer to the package page for the complete list and their definitions. A detailed discussion requires great understanding of the MCL algorithm in \cite{thrun2005probabilistic}, which we omit here. We provide an \emph{example} of fine tuning these parameters and describe their results qualitatively. The actual parameters you use should depend on your laser scanner and robot.

\texttt{amcl}包中列出了有关调整激光扫描仪模型（测量）和里程计模型（运动）的参数。
有关完整列表及其定义，请参阅\texttt{amcl}包页面。
对这参数的详细讨论需要理解论文\cite{thrun2005probabilistic}的MCL算法，我们在此省略该部分内容。
我们提供了一个\emph{示例}展示如何调整这些参数，并定性描述它们的结果。
实际参数应根据所使用的激光扫描仪和机器人作调整。

%For \textbf{laser scanner model}, the default parameters are:
对于\textbf{激光扫描模型}，默认的参数为：

\lstset{language=bash}
\begin{lstlisting}
{
"laser_z_hit": 0.5,
"laser_sigma_hit": 0.2,
"laser_z_rand" :0.5,
"laser_likelihood_max_dist": 2.0
}
\end{lstlisting}

%To improve the localization of our robot, we increased \texttt{laser\_z\_hit} and \texttt{laser\_sigma\_hit} to incorporate higher measurement noise. The resulting parameters are:

为了改善机器人的定位精度，我们增加了\texttt{laser\_z\_hit}和\texttt{laser\_sigma\_hit}参数来引入更多噪音测量。最后的参数为：

\lstset{language=json}
\begin{lstlisting}
{
"laser_z_hit": 0.9,
"laser_sigma_hit": 0.1,
"laser_z_rand" :0.5,
"laser_likelihood_max_dist": 4.0
}
\end{lstlisting}
%The behavior is illustrated in Figure~\ref{fig:param1} and \ref{fig:param2}. It is clear that in our case, adding noise into the measurement model helped with localization.
机器人的行为如图〜\ref{fig:param1}和\ref{fig:param2}所示。显然，在我们的案例中，在测量模型中增加噪声测量有助于定位。

\begin{figure}[!tb]
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{param1.png}
	\caption{默认测量模型参数}%{Default measurement model parameters}
	\label{fig:param1}
	\endminipage\hfill
	\minipage{0.49\textwidth}
	\includegraphics[width=\linewidth]{param2.png}
	\caption{调整测量模型参数后（增加噪声）}%{After tuning measurement model parameters (increase noise)}
	\label{fig:param2}
	\endminipage\hfill
\end{figure}

%For the \textbf{odometry model}, we found that our odometry was quite reliable in terms of stability. Therefore, we tuned the parameters so that the algorithm assumes there is low noise in odometry:

对于\textbf{里程计模型}，我们发现我们的里程计非常稳定。因此，我们调整了参数，便于算法假设里程计中的噪音很低：

\lstset{language=json}
\begin{lstlisting}
{   
"kld_err": 0.01,
"kld_z": 0.99,
"odom_alpha1": 0.005,
"odom_alpha2": 0.005,
"odom_alpha3": 0.005,
"odom_alpha4": 0.005
}
\end{lstlisting}
%To verify that the above paremeters for motion model work, we also tried a set of parameters that suggest a noisy odometry model:
为验证上述参数对运动模型是否有效，我们还尝试了一组受噪声污染的里程模型的建议参数：
\lstset{language=json}
\begin{lstlisting}
{
"kld_err": 0.10,
"kld_z": 0.5',                                                                            
"odom_alpha1": 0.008,                                                                     
"odom_alpha2": 0.040,                                                                     
"odom_alpha3": 0.004,                                                                     
"odom_alpha4": 0.025                                                                      
} 
\end{lstlisting}
%We observed that when the odometry model is less noisy, the particles are more condensed. Otherwise, the particles are more spread-out.
我们观察到，当里程模型噪声较小时，粒子会更加收缩；否则，粒子会更加分散。

\subsection[Translation of the laser scanner]{激光扫描仪的平移问题}

%There is a \texttt{tf} transform from \texttt{laser\_link} to \texttt{base\_footprint} or \texttt{base\_link} that indicates the pose of the laser scanner with respect to the robot base. If this transform is not correct, it is very likely that the localization behaves strangely.
%In this situation, we have observed constant shifting of laser readings from the walls of the environment, and sudden drastic change in the localization. 
%It is straightforward enough to make sure the transform is correct;
%This is usually handled in \texttt{urdf} and \texttt{srdf} specification of your robot. However, if you are using a \texttt{rosbag} file, you may have to publish the transform youself.

ROS中有个\texttt{tf}变换可以将坐标系从\texttt{laser\_link}转换为\texttt{base\_footprint}或\texttt{base\_link}，表示激光扫描仪相对于机器人基座的姿态。如果此变换不正确，则很可能导致机器人的定位行为难以理解。
在那种情况下，我们观察到激光传感器扫描环境中的墙壁时其读数有一定的漂移，并且定位产生剧烈变化。
这种检验方式足够简单，用以确保\texttt{tf}变换无误;
通常在机器人的\texttt{urdf}和\texttt{srdf}规范中有相应的处理方式。
但是，如果您使用的是\texttt{rosbag}文件，则必须自行发布\texttt{tf}转换。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section[Recovery Behaviors]{恢复行为}%{Recovery Behaviors}
%An annoying thing about robot navigation is that the robot may get stuck. Fortunately, the navigation stack has recovery behaviors built-in. Even so, sometimes the robot will exhaust all available recovery behaviors and stay still. Therefore, we may need to figure out a more robust solution.

机器人导航过程中比较头疼的一个问题是机器人可能会被卡住。 幸运的是，导航功能包内置了恢复行为。 
即便如此，有时机器人会耗尽所有可用的恢复行为后保持静止。因此，我们需要一个更强大的解决方案。

%\paragraph{Types of recovery behaviors} 
%ROS navigation has two recovery behaviors. They are \texttt{clear\_costmap\_recovery} and \texttt{rotate\_recovery}. Clear costmap recovery is basically reverting the local costmap to have the same state as the global costmap. Rotate recovery is to recover by rotating 360 degrees in place. 
%恢复行为的种类：ROS导航包有两种恢复行为，分别是清除代价地图恢复和旋转恢复。清除代价地图恢复是将本地代价地图还原成全局代价地图的状态。旋转恢复是通过旋转360°来恢复。
\textbf{恢复行为的种类}：ROS导航功能包有两种恢复行为。它们是\texttt{clear\_costmap\_recovery}和\texttt{rotate\_recovery}。
清除代价地图恢复本质上是将局部代价地图恢复为与全局代价地图等价的状态。
旋转恢复是通过旋转360°来恢复。

\paragraph{Unstuck the robot} Sometimes rotate recovery will fail to execute due to rotation failure. At this point, the robot may just give up because it has tried all of its recovery behaviors - clear costmap and rotation. In most experiments we observed that when the robot gives up, there are actually many ways to unstuck the robot. 
To avoid giving up, we used SMACH to continuously try different recovery behaviors, with additional ones such as setting a temporary goal that is very close to the robot, and returning to some previously visited pose (i.e. backing off). These methods turn out to improve the robot's durability substantially, and unstuck it from previously hopeless tight spaces from our experiment observations\footnote{Here is a video demo of my work on mobile robot navigation: \url{https://youtu.be/1-7GNtR6gVk}}.

\textbf{解救机器人}：有时由于旋转故障，旋转恢复无法获得执行。此时，机器人可能会选择放弃，因为它已经尝试了所有的恢复行为--清除代价地图和旋转恢复。
我们观察到，在大多数试验中，当机器人选择放弃行为时，实际上仍有很多方法可以解救机器人。
为了避免放弃，我们使用SMACH来连续尝试不同的恢复行为，通过其他额外的行为，例如设置非常接近机器人的临时目标，并返回到以前访问过的姿态（即退出）。这些方法可以显著提高机器人的耐久性，并且从以前观察到的无望空间中解救出来\footnote{这是我在开展移动机器人导航方面的工作时的一个演示视频: \url{https://youtu.be/1-7GNtR6gVk}}。

\begin{figure}[!h]
	\begin{center}
		\includegraphics[width=26em]{Recovery.png} 
		\caption{SMACH中的简单恢复状态}
		%{Simple recovery state in SMACH}
	\end{center}
\end{figure}


%\paragraph{Parameters} The parameters for ROS's recovery behavior can be left as default in general. For clear costmap recovery, if you have a relatively high \texttt{sim\_time}, which means the trajectory is long, you may want to consider increasing \texttt{reset\_distance} parameter, so that bigger area on local costmap is removed, and there is a
%better chance for the local planner to find a path.

\textbf{参数}：ROS的恢复行为的参数一般可以保留为默认值。为了清除代价地图进行恢复，你可以设置一个相对较高的模拟时间\texttt{sim\_time}，这意味着轨迹很长，你可能需要考虑增加\texttt{reset\_distance}参数的值，这样可以消除本地代价地图上更大的区域，并且局部规划器有更好的机会寻找一条路径。

\section[Dynamic Reconfigure]{动态重新配置}%{Dynamic Reconfigure}

One of the most flexible aspect about ROS navigation is dynamic reconfiguration, since different parameter setup might be more helpful for certain situations, e.g. when robot is close to the goal. Yet, it is not necessary to do a lot of dynamic reconfiguration. 

ROS导航最灵活的特性之一是动态重新配置，因为不同的参数设置可能对某些情况（如机器人靠近目标点时）更有帮助。即便如此，没有必要进行大量的动态重新配置。

%\paragraph{Example} One situation that we observed in our experiments is that the robot tends to fall off the global path,
%even when it is not necessary or bad to do so. Therefore we increased \texttt{path\_distance\_bias}. Since a high \texttt{path\_distance\_bias} will make the robot stick to the global path, which does not actually lead to the final goal due to tolerance, we need a way to let the robot reach the goal with no hesitation. We chose to dynamically
%decrease the \texttt{path\_distance\_bias} so that \texttt{goal\_distance\_bias} is emphasized when the robot is close to the goal. After all, doing more experiments is the ultimate way to find problems and figure out solutions.


\textbf{示例}：
我们在实验中观察到的一种情况是机器人常常会脱离全局路径，即使没有必要这么做或者这样做会带来不好的结果。
因此我们增加了路径距离偏差\texttt{path\_distance\_bias}。由于大的路径距离偏差值\texttt{path\_distance\_bias}将使机器人遵循全局路径，但实际上由于容差的原因机器人并不会最终到达目标点，我们需要一种方法让机器人毫不犹豫地达到目标点。
此时，我们动态减少路径距离偏差\texttt{path\_distance\_bias}，以便在机器人接近目标点时强调\texttt{goal\_distance\_bias}。
毕竟，做更多的实验是为了找到解决问题的方法。

\section[Problems]{问题}%{Problems}

\begin{enumerate}
	\item 陷入困境。 %Getting stuck 	
	%	This is a problem that we face a lot when using ROS navigation. In both simulation and reality, the robot gets stuck and gives up the goal. 
	在使用ROS导航的时候，这个问题经常出现，无论是在仿真还是实际中，机器人都可能陷入困境然后放弃目标
	
	\item 不同方向采用不同的速度。%Different speed in different directions 
	
	%	We observed some weird behavior of the navigation stack. When the goal is set in the -x direction with respect to TF origin, dwa local planner plans less stably (the local planned trajectory jumps around) and the robot moves really slowly. But when the goal is set in the +x direction, dwa local planner is much more stable, and the robot can move faster.
	在导航功能包中我们观察到一些奇怪的行为。当目标点设置在相对于TF原点的-x方向时，dwa局部规划器规划表现不稳定（局部规划的路径存在跳跃行为），而且机器人的移动速度非常缓慢。
	但是当把目标设置在+x方向时，dwa局部规划器就比较稳定了，并且移动速度很快。
	
	%	I reported this issue on Github here: \url{https://github.com/ros-planning/navigation/issues/503}. 
	%	Nobody attempted to resolve it yet.
	我在github上报告了这个问题：\url{https://github.com/ros-planning/navigation/issues/503}。目前还没有人尝试解决它。
	
	\item 实际VS.仿真。 %Reality VS. simulation 
	
	%	There is a difference between reality and simulation. In reality, there are more obstacles with various shapes. For exmaple, in the lab there is a vertical stick that is used to hold to door
	%	open. Because it is too thin, the robot sometimes fails to detect it and hit on it. There are also more complicated human activity in reality.
	
	实际运行与仿真运行是有差别的。现实情况中，障碍物有各种各样的形状。例如，实验室有一个垂直的柜子，用以防止门关闭；由于柜子太细，机器人有时无法检测到柜子然后撞上柜子。而且实际中也会存在更复杂的人类活动。
	
	\item 不一致性。%Inconsistency 
	
	%	Robots using ROS navigation stack can exhibit inconsistent behaviors, for example when entering a door, the local costmap is generated again and again with slight difference each time, and this may affect path planning, especially when resolution is low. Also, there is no memory for the robot. It does not remember how it entered the room from the door the last time. So it needs to start out fresh again every time it tries to enter a door. Thus, if it enters the door in a different angle than before, it may just get stuck and give up.
	
	使用ROS导航功能包可能会出现不一致的行为。例如进门时，不同时间里局部规划器会一次又一次地生成差异较小的代价地图，这可能会影响路径规划，特别是在分辨率较低的时候。另外，机器人没有内存时，它不记得上次是怎么从门进入房间的，所以每次尝试进门都需要重新开始尝试。因此，如果机器人进门时采用与以前进门不同的角度，机器人可能会卡住并最终放弃目标。
	
\end{enumerate}


\section*{致谢}

%Hope this guide is helpful. Please feel free to add more information from your own experimental observations.
希望本指南对你有所帮助。 请随意添加你在自己的实验中观察到的更多信息。
